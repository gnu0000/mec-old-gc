/*
 *
 * genop.c
 * Wednesday, 3/5/1997.
 * Craig Fitzgerald
 *
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <GnuType.h>
#include <GnuMem.h>
#include <GnuMisc.h>
#include <GnuFile.h>
#include "gclib.h"
#include "gc.h"
#include "symbol.h"
#include "tokenize.h"
#include "parse.h"
#include "check.h"
#include "label.h"
#include "genexpr.h"
#include "opcodes.h"
#include "binfile.h"
#include "genfn.h"
#include "genop.h"
#include "error.h"


#define MAX_FUNCTION_SIZE 0x4000
#define PEEP_SIZE         4

static UCHAR pszCODE [MAX_FUNCTION_SIZE];

static INT   iIP;                     // Code Area current size Index
static INT   iLASTOPPOS [PEEP_SIZE];

UINT uOPT = 0xFF;

/***************************************************************************/
/*                                                                         */
/* Functions that support cursor management for peephole optimization      */
/*                                                                         */
/***************************************************************************/

/*
 * called by label module
 * this says a label has been dropped to the current IP
 * therefore an opcode merge optimization cannot take place here
 */
void CodClearMerge (void)
   {
   int i;

   for (i=PEEP_SIZE; i; i--)
      iLASTOPPOS[i-1] = 0;
   }


static void SetOpPos (INT iPos)
   {
   UINT i;

   for (i=PEEP_SIZE-1; i; i--)
      iLASTOPPOS[i] = iLASTOPPOS[i-1];

   iLASTOPPOS[0] = iPos;
   }


static void BackupPos (void)
   {
   UINT i;

   for (i=1; i<PEEP_SIZE; i++)
      iLASTOPPOS[i-1] = iLASTOPPOS[i];
   iLASTOPPOS[PEEP_SIZE-1] = 0;
   }


static UCHAR LastOp (UINT uIdx)
   {
   UINT i;

   for (i=0; i<=uIdx; i++)
      if (!iLASTOPPOS[i])
         return 0;
   return pszCODE [iLASTOPPOS[uIdx]];
   }

static INT OpPos (UINT uIdx)
   {
   UINT i;

   for (i=0; i<uIdx; i++)
      if (!iLASTOPPOS[i])
         return 0;
   return iLASTOPPOS[uIdx];
   }

/***************************************************************************/
/*                                                                         */
/* Optimization routines                                                   */
/*                                                                         */
/***************************************************************************/

/*
 * performs a mini optimization in stack increments and decrements
 * this is a peephole of size 2
 * merges:  ISP, ISP -> ISP or DSP
 *          ISP, DSP -> ISP or DSP
 *          DSP, ISP -> ISP or DSP
 *          DSP, DSP -> ISP or DSP
 *          SAV, DSP -> POP only in some cases
 *
 *          PUSHI, ADDRL, SAVGS, DSP -> POPL only in some cases
 *          PUSHI, ADDRG, SAVGS, DSP -> POPG only in some cases
 *
 *
 *
 */
static BOOL MergeOp1 (UCHAR cOp, INT s)
   {
   PSHORT ps;
   UCHAR  cLastOp;
   INT    iSize, iStartIP, iOffset;

   if (!iLASTOPPOS[0])
      return FALSE;

   cLastOp = LastOp (0);
   ps      = (PSHORT)(pszCODE + OpPos(0) + 1);

   if (cOp == OP_ISP || cOp == OP_DSP)
      {
      if (!s)         // increment or decrement 0?
         return TRUE;

      if (cLastOp == OP_ISP || cLastOp == OP_DSP)
         {
         *ps += (cOp == cLastOp ? s : -s);
         if (!*ps)  // did they cancel?
            {
            iIP = OpPos(0);
            BackupPos ();
            }
         if (*ps < 0)
            {
            *ps = -*ps;
            pszCODE[OpPos(0)] = (cLastOp == OP_ISP ? OP_DSP : OP_ISP);
            }
         return TRUE;
         }
      }

   /*
    * This sequence is often generated by a simple l value assignment
    *
    *    PUSHI [B] -or- [S] -or- [W] off
    *    ADDRL or ADDRG
    *    SAVGS [C] -or- [S] -or- [W] -or- [F]
    *    DSP   1 -or- 2
    *
    * it can be replaced by:
    *
    *    POPL off or POPG off
    *
    */
   if ((uOPT & 0x04) && cOp == OP_DSP && 
       (cLastOp >= OP_SAVGS && cLastOp <= OP_SAVGS+3) &&
       (LastOp(1) == OP_ADDRG || LastOp(1) == OP_ADDRL)     &&
       (LastOp(2) >= OP_PUSHI && LastOp(2) <= OP_PUSHI+3)   &&
       (s == ((cLastOp & 0x03) == M_FLOAT ? 2 : 1)))
      {
      if (LastOp(2) == OP_PUSHI+M_BYTE)
         iOffset = (UINT) pszCODE[OpPos(2)+1];
      if (LastOp(2) == OP_PUSHI+M_SHORT)
         iOffset = *(PSHORT)(pszCODE + OpPos(2)+1);
      else
         iOffset = (INT)*(PLONG)(pszCODE + OpPos(2)+1);

      iStartIP = OpPos(2);
      pszCODE[iStartIP]   = (LastOp(1) == OP_ADDRL ? OP_POPL : OP_POPG) + cLastOp - OP_SAVGS;
      pszCODE[iStartIP+1] = (CHAR)(iOffset & 0xFF);
      pszCODE[iStartIP+2] = (CHAR)(iOffset >> 8);

      iIP = iStartIP+3;
      CodClearMerge ();
      return TRUE;
      }

   if (cOp == OP_DSP && cLastOp >= OP_SAVL && cLastOp <= OP_SAVGS+3)
      {
      iSize = ((cLastOp & 0x03) == M_FLOAT ? 2 : 1);
      if (s == iSize)
         {
         /*--- convert SAV to POP ---*/
         pszCODE[OpPos(0)] = cLastOp - OP_SAVL + OP_POPL;
         return TRUE;
         }
      }
   if (cOp == OP_DSP && (cLastOp == OP_SAVNL || cLastOp == OP_SAVNG))
      {
      /*--- I'm assuming SAVNL/G size is = to DSP size ---*/
      /*--- convert SAV to POP ---*/
      pszCODE[OpPos(0)] = (cLastOp == OP_SAVNL ? OP_POPNL : OP_POPNG);
      return TRUE;
      }
   return FALSE;
   }


/*
 * PUSHI[W] -> PUSHI[S]
 *             PUSHI[C]
 *             PUSH0
 *             PUSH1
 *
 */
static BOOL MergeOp2W (UCHAR cOp, LONG w)
   {
   if (cOp != OP_PUSHI)
      return FALSE;

   if (!w)
      AddOp (OP_PUSH0, 0);

   else if (w == 1)
      AddOp (OP_PUSH1, 0);

   else if (w > 0 && w < 256)
      AddOpC (OP_PUSHI, DATATYPE_CHAR, (UCHAR)w);

   else if (w > -32767L && w < 32768L)
      AddOpS (OP_PUSHI, DATATYPE_SHORT, (SHORT)w);

   else
      return FALSE;

   return TRUE;

   }



/*
 * PUSHI[S] -> PUSHI[C]
 *             PUSH0
 *             PUSH1
 *             
 *
 */
static BOOL MergeOp2S (UCHAR cOp, SHORT s)
   {
   if (cOp != OP_PUSHI)
      return FALSE;

   if (!s)
      AddOp (OP_PUSH0, 0);

   else if (s == 1)
      AddOp (OP_PUSH1, 0);

   else if (s > 0 && s < 256)
      AddOpC (OP_PUSHI, DATATYPE_CHAR, (UCHAR)s);

   else
      return FALSE;

   return TRUE;
   }


/*
 * OP_BYTE and OP_SHORT optimizations
 * ----------------------------------
 * PUSHI[b,s,w],  BYTE -> PUSHI[B]
 * PUSHI[s,w],   SHORT -> PUSHI[S]
 * PUSHI[b],     SHORT -> PUSHI[b]
 *
 * PUSHL[b,s,w],  BYTE -> PUSHL[b]
 * PUSHLS[b,s,w], BYTE -> PUSHLS[b]
 * PUSHG[b,s,w],  BYTE -> PUSHG[b]
 * PUSHGS[b,s,w], BYTE -> PUSHGS[b]
 *
 * PUSHL[s,w],   SHORT -> PUSHL[s]
 * PUSHLS[s,w],  SHORT -> PUSHLS[s]
 * PUSHG[s,w],   SHORT -> PUSHG[s]
 * PUSHGS[s,w],  SHORT -> PUSHGS[s]
 *
 * PUSHL[b],   SHORT -> PUSHL[b]
 * PUSHLS[b],  SHORT -> PUSHLS[b]
 * PUSHG[b],   SHORT -> PUSHG[b]
 * PUSHGS[b],  SHORT -> PUSHGS[b]
 *
 */
static BOOL MergeOp3 (UCHAR cOp, INT s)
   {
   PSHORT ps;
   UCHAR  cLastOp, cLastOpM, cLastOpO;

   if (!iLASTOPPOS[0])
      return FALSE;

   cLastOp  = LastOp (0);
   cLastOpM = cLastOp & 0x03;
   cLastOpO = cLastOp & 0xFC;
   ps       = (PSHORT)(pszCODE + OpPos(0) + 1);

   if (cLastOpM != M_BYTE && cLastOpM != M_SHORT && cLastOpM != M_WORD)
      return FALSE;

   if (cOp == OP_BYTE)
      {
      if (cLastOpO == OP_PUSHL || cLastOpO == OP_PUSHLS ||
          cLastOpO == OP_PUSHG || cLastOpO == OP_PUSHGS ||
          cLastOpO == OP_PUSHI )
         {
         pszCODE [OpPos(0)] = (pszCODE [OpPos(0)] & 0xFC) | M_BYTE;

         if (cLastOpO == OP_PUSHI)
            {
            if (cLastOpM == M_SHORT)
               {
               pszCODE [iIP-2] = pszCODE [iIP-1];
               iIP--;
               }
            else // (cLastOpM == M_WORD)
               {
               pszCODE [iIP-4] = pszCODE [iIP-1];
               iIP -= 3;
               }
            }
         return TRUE;
         }
      }
   if (cOp == OP_SHORT)
      {
      if (cLastOpO == OP_PUSHL || cLastOpO == OP_PUSHLS ||
          cLastOpO == OP_PUSHG || cLastOpO == OP_PUSHGS ||
          cLastOpO == OP_PUSHI )
         {
         if (cLastOpM == M_BYTE || cLastOpM == M_SHORT)
            return TRUE;

         pszCODE [OpPos(0)] = (pszCODE [OpPos(0)] & 0xFC) | M_SHORT;

         if (cLastOpO == OP_PUSHI)
            {
            pszCODE [iIP-4] = pszCODE [iIP-2];
            pszCODE [iIP-3] = pszCODE [iIP-1];
            iIP -= 2;
            }
         return TRUE;
         }
      }
   return FALSE;
   }



/***************************************************************************/
/*                                                                         */
/* External function to add opcodes to the code stream                     */
/*                                                                         */
/***************************************************************************/

/*
 * given a datatype this fn returns the 2 bit datatype spec that is
 * combined with a base opcode to generate a datatype specific opcode
 */
static UINT OpFix2 (UINT uDataType)
   {
   switch (uDataType)
      {
      case 0              : return M_WORD; // assume not void
      case DATATYPE_CHAR  : return M_BYTE;
      case DATATYPE_SHORT : return M_SHORT;
      case DATATYPE_LONG  : return M_WORD;
      case DATATYPE_FLOAT : return M_FLOAT;
      case DATATYPE_STRING: return M_WORD;
      case DATATYPE_PTR   : return M_WORD;

      default             : return M_WORD; // includes structures
      }
   }

/*
 *
 *
 */
void AddOp (UINT uOp, UINT uType)
   {
   if ((uOPT & 0x08) && MergeOp3 ((UCHAR)uOp, uType))
      return;

   switch (uOp)
      {
//    case OP_NOP:       // 0x00
//    case OP_CALL:      // 0x01
//    case OP_CALLI:     // 0x02
//    case OP_JMP:       // 0x03
//    case OP_JZ:        // 0x04
//    case OP_JNZ:       // 0x05
//    case OP_JZK:       // 0x06
//    case OP_JNZK:      // 0x07
//    case OP_PUSHSF:    // 0x08
//    case OP_PUSHSP:    // 0x09
//    case OP_POPSF:     // 0x0A
//    case OP_PUSH0:     // 0x0B
//    case OP_PUSH1:     // 0x0C
//    case OP_DUPS:      // 0x0D
//    case OP_SWAPS:     // 0x0E
//    case OP_ISP:       // 0x50
//    case OP_DSP:       // 0x51
//    case OP_FTOW:      // 0x52
//    case OP_WTOF:      // 0x53
//    case OP_SHR:       // 0xA0
//    case OP_SHL:       // 0xA2
//    case OP_AND:       // 0xA4
//    case OP_XOR:       // 0xA6
//    case OP_OR:        // 0xA8
//    case OP_NOT:       // 0xAA
//       break;

      case OP_GT:        // 0x80 x  w and f varieties
      case OP_LT:        // 0x82 x
      case OP_GE:        // 0x84 x
      case OP_LE:        // 0x86 x
      case OP_EQ:        // 0x88 x
      case OP_NE:        // 0x8A x
      case OP_ZE:        // 0x8C x
      case OP_NZ:        // 0x8E x
      case OP_ADD:       // 0x90 x
      case OP_SUB:       // 0x92 x
      case OP_MUL:       // 0x94 x
      case OP_DIV:       // 0x96 x
      case OP_MOD:       // 0x98 x
      case OP_NEG:       // 0x9A x
      case OP_LAND:      // 0xB0 x
      case OP_LOR:       // 0xB2 x
      case OP_LNOT:      // 0xB4 x
         if (uType == DATATYPE_FLOAT)
            uOp |= M_FLOAT;
         break;

      case OP_SAVL:      // 0x10 xx c, s, w and f varieties
      case OP_SAVLS:     // 0x14 xx
      case OP_SAVG:      // 0x18 xx
      case OP_SAVGS:     // 0x1C xx
      case OP_POPL:      // 0x10 xx c, s, w and f varieties
      case OP_POPLS:     // 0x14 xx
      case OP_POPG:      // 0x18 xx
      case OP_POPGS:     // 0x1C xx
      case OP_PUSHL:     // 0x20 xx
      case OP_PUSHLS:    // 0x24 xx
      case OP_PUSHG:     // 0x28 xx
      case OP_PUSHGS:    // 0x2C xx
      case OP_PUSHI:     // 0x30 xx c, s, w and f varieties
      case OP_INCL:      // 0x40 xx
      case OP_INCG:      // 0x44 xx
      case OP_DECL:      // 0x48 xx
      case OP_DECG:      // 0x4C xx
         uOp |= OpFix2 (uType);
         break;

      }
   SetOpPos (iIP);
   pszCODE[iIP++] = (UCHAR)uOp;
   }


void AddOpL (UINT uOp, UINT uType, PLBL pl)
   {
   Log (0x20, "AddOpL IP:%4.4x  [%x typ %x ] [%x]\n", iIP, uOp, uType, pl->iIP);

   AddOp (uOp, uType);
   AddShort (LabPos (pl));
   }

void AddOpA (UINT uOp, UINT uType, ULONG ul, USHORT uScope)
   {
   Log (0x20, "AddOpA IP:%4.4x  [%x typ %x ] [%lx]\n", iIP, uOp, uType, ul);


   AddOp (uOp, uType);

   if (uScope == SCOPE_GLOBAL)
      AddWord (ul);
   else
      AddShort ((USHORT)ul);


   }

void AddOpW (UINT uOp, UINT uType, LONG w)
   {
   Log (0x20, "AddOpW IP:%4.4x  [%x typ %x ] [%lx]\n", iIP, uOp, uType, w);

   if ((uOPT & 0x02) && MergeOp2W ((UCHAR)uOp, w))
      return;

   AddOp (uOp, uType);
   AddWord (w);
   }

void AddOpS (UINT uOp, UINT uType, INT s)
   {
   Log (0x20, "AddOpS IP:%4.4x  [%x typ %x ] [%x]\n", iIP, uOp, uType, s);

   if ((uOPT & 0x01) && MergeOp1 ((UCHAR)uOp, s))
      return;
   if ((uOPT & 0x02) && MergeOp2S ((UCHAR)uOp, s))
      return;

   AddOp (uOp, uType);
   AddShort (s);
   }


void AddOpC (UINT uOp, UINT uType, CHAR c)
   {
   Log (0x20, "AddOpS IP:%4.4x  [%x typ %x ] [%x]\n", iIP, uOp, uType, c);

   AddOp (uOp, uType);
   AddChar (c);
   }


void AddOpF (UINT uOp, UINT uType, BIG bg)
   {
   Log (0x20, "AddOpF IP:%4.4x  [%x typ %x ] [%lf]\n", iIP, uOp, uType, bg);

   AddOp (uOp, uType);
   AddFloat (bg);
   }


/***************************************************************************/
/*                                                                         */
/* External functions to add operand data to the code stream               */
/*                                                                         */
/***************************************************************************/


void AddChar (INT iWord)
   {
   pszCODE[iIP++] = iWord;
   }


void SetShort (UINT uAddr, SHORT iWord)
   {
   PSHORT piWord;

   piWord = (PSHORT)(pszCODE + uAddr);
   *piWord = iWord;
   }


void AddShort (SHORT iWord)
   {
   PSHORT piWord;

   piWord = (PSHORT)(pszCODE + iIP);
   *piWord = iWord;
   iIP += 2;
   }

void AddWord (LONG l)
   {
   PLONG pl;

   pl = (PLONG)(pszCODE + iIP);
   *pl = l;
   iIP += 4;
   }

void AddFloat (BIG bg)
   {
   PBIG pbg;

   pbg = (PBIG)(pszCODE + iIP);
   *pbg = bg;
   iIP += 8;
   }

/***************************************************************************/
/*                                                                         */
/* External functions to init and get access                               */
/*                                                                         */
/***************************************************************************/

void CodInitBuffer (void)
   {
   iIP = 0;
   }


PSZ CodBuffer (PUINT puLen)
   {
   if (puLen)
      *puLen = iIP;
   return pszCODE;
   }
